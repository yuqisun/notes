#### 使用 Redis构建锁
SETNX 只会在键不存在的情况下为键设置值，而锁要做的就是将一个随机生成的128位 UUID设置为键的值，并使用这个值来防止锁被其他进程取得。

`if pipe.get(lockname) == identifier ......` 释放锁之前进行判断，检查进程是否仍然持有锁，也防止释放别人的锁。

#### 带有超时限制的锁
调用 EXPIRE命令来为锁设置过期时间。

#### 计数信号量
通常用于限定能够同时使用的资源数量，之前构建的锁可以看作只能被一个进程访问的信号量。当客户端获取锁失败的时候通常会等待，而获取计数信号量失败的时候，通常会选择立即返回失败结果，表示该资源正在被占用。

使用有序集合 ZSET，进程在尝试获取信号量时会生成一个标识符，并使用当前时间戳作分值，将标识符添加到有序集合中，进程会检查自己的标识符在有序集合中的排名，如果排名低于可获取的信号量的总数，那么表示进程成功地获取了信号量。

#### 公平信号量
为了减少系统时间不一致带来的问题，需要给信号量添加一个计数器以及一个有序集合。计数器通过自增操作，确保最先对计数器执行自增操作的客户端获得信号量。

#### FIFO 任务队列
使用 LIST，rpush, blpop实现推入和弹出。

#### 多个可执行任务队列
加一个回调函数

#### 任务优先级队列
分高，中，低三个优先级，可以使用 `blpop key-name [key-name ...] timeout`从第一个非空列表中弹出最左元素。
