## 字典
hash表负载因子 = 哈希表已保存节点数量 / 哈希表大小  
load_factor = ht[0].used / ht[0].size

#### 哈希表的扩展与收缩
1. 扩展与收缩条件
2. 按照 rehashidx 进行渐进式 rehash（字典包含两个 hash表 ht[0] 和 ht[1]，用于复制，类似于cluster槽从一个节点的转移到另一个）
3. 渐进式 rehash执行期间的哈希表操作

## 对象
1. 对象的内部结构
2. 引用计数内存回收
3. 引用计数实现多数据库键共享同一对象，节约内存
4. 对象带有访问时间记录信息，记录空转时间，超过maxmemory时，释放空转时间长的键

#### 字符串对象
* 编码
  1. int - 保存的是整数值，且可以用 long类型来表示
  2. raw - 保存的是一个字符串值，且长度大于 39字节，使用SDS来保存这个字符串
  3. embstr - 保存的是一个字符串值，且长度小于等于 39字节，embstr是专门用于保存短字符的一种优化编码方式
* embstr 优点

## 数据库
#### 读写键空间时的维护操作
1. 记录命中和不命中次数，可以在 INFO stats 中看到
2. 更新最后一次使用时间(LRU)，用于计算闲置时间
3. 如果键过期则删除
4. 如果有客户端 watch了某个键，将键标记为 dirty
5. ...

#### 设置过期时间
EXPIRE, PEXPIRE, EXPIREAT 三个命令都是使用 PEXPIREAT 命令来实现的

#### 过期键的判定
1. 检查过期字典
2. 检查当前 UNIX 时间戳是否大于键的过期时间

#### 过期键删除策略
惰性删除和过期删除  

#### RDB文件对过期键的处理
已过期键不会被保存到新创建的 RDB文件中  

* 载入RDB文件
  * 主服务器忽略过期键
  * 从服务器不忽略

#### AOF写入对过期键的处理
没有被删除的键没有影响，已经删除的，追加 DEL命令到AOF文件中

#### 主从
从服务器的过期键由主服务器控制，自己不能删除

## RDB 创建与载入
* SAVE 阻塞
* BGSAVE　派生子进程

因为AOF更新频率高，如果 AOF开启，优先使用AOF。

#### RDB 文件结构
RDB文件保存字符串大于 20字节会压缩后进行保存，小于等于 20字节原样保存。REDIS_RDB_ENC_LZF 常量标志字符串已经被 LZF算法压缩过了，读入时通过 compressed_len, origin_len, compressed_string 三部分对字符串解压缩。


## AOF持久化
#### AOF文件的载入与数据还原
创建一个不带网络连接的伪客户端执行AOF文件中的命令。

#### AOF重写(BGREWRITEAOF)
为了防止AOF文件膨胀，提供了AOF重写。通过读取当前的数据库状态进行重写。如果重写时集合元素超过 64个，则会分成多条写入。

#### AOF重写期间数据一致性
使用 AOF重写缓冲区，客户端发送命令时，同时追加命令到 AOF缓冲区和 AOF重写缓冲区。
1. 当 AOF重写缓冲区中所有内容都写入新 AOF文件中时，新的 AOF和当前数据库一致
2. 对新的 AOF文件进行改名，覆盖现有 AOF文件，完成新旧 AOF文件互换

## 事件
1. 文件事件
2. 时间事件（如serverCron函数）

## 服务器
#### 命令请求过程
1. 发送命令请求
2. 读取命令请求
3. 查找命令表
4. 执行预备操作
5. 调用命令函数
6. 执行后续工作
7. 回复命令　

#### serverCron 函数

#### 初始化服务器

## 复制
#### 旧版复制 SYNC
Redis 2.8之前，断点重新连接后重新执行一次 SYNC 命令，效率低。

#### 新版复制 PSYNC(partial resync)
1. 根据 runId判断从服务器是断线重连还是新连接
2. 复制偏移量记录上次复制到哪
3. 复制积压缓冲区(FIFO队列)记录断线期间的命令，超出缓冲区容量将完整复制

## Sentinel
#### 启动并初始化 Sentinel
创建向主服务器的网络连接：
1. 命令连接
2. 订阅连接



## 选举领头
### 选举领头 Sentinel(Raft算法的领头选举)
### Cluster 选举新的主节点(Raft算法的领头选举)

## 故障转移
### Sentinel故障转移
##### 选出新的主服务器
1. 从服务器优先级
2. 偏移量(偏移量最大的保存着最新的数据)
3. 运行ID 最小的服务器
### Cluster故障转移


