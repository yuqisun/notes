## 字典
hash表负载因子 = 哈希表已保存节点数量 / 哈希表大小  
load_factor = ht[0].used / ht[0].size

#### 哈希表的扩展与收缩
1. 扩展与收缩条件
2. 按照 rehashidx 进行渐进式 rehash（字典包含两个 hash表 ht[0] 和 ht[1]，用于复制，类似于cluster槽从一个节点的转移到另一个）
3. 渐进式 rehash执行期间的哈希表操作

## 对象
1. 对象的内部结构
2. 引用计数内存回收
3. 引用计数实现多数据库键共享同一对象，节约内存
4. 对象带有访问时间记录信息，记录空转时间，超过maxmemory时，释放空转时间长的键

#### 字符串对象
* 编码
  1. int - 保存的是整数值，且可以用 long类型来表示
  2. raw - 保存的是一个字符串值，且长度大于 39字节，使用SDS来保存这个字符串
  3. embstr - 保存的是一个字符串值，且长度小于等于 39字节，embstr是专门用于保存短字符的一种优化编码方式
* embstr 优点

## 数据库
#### 读写键空间时的维护操作
1. 记录命中和不命中次数，可以在 INFO stats 中看到
2. 更新最后一次使用时间(LRU)，用于计算闲置时间
3. 如果键过期则删除
4. 如果有客户端 watch了某个键，将键标记为 dirty
5. ...

#### 设置过期时间
EXPIRE, PEXPIRE, EXPIREAT 三个命令都是使用 PEXPIREAT 命令来实现的

#### 过期键的判定
1. 检查过期字典
2. 检查当前 UNIX 时间戳是否大于键的过期时间

#### 过期键删除策略
惰性删除和过期删除  

#### RDB文件对过期键的处理
已过期键不会被保存到新创建的 RDB文件中  

* 载入RDB文件
  * 主服务器忽略过期键
  * 从服务器不忽略

#### AOF写入对过期键的处理
没有被删除的键没有影响，已经删除的，追加 DEL命令到AOF文件中

#### 主从
从服务器的过期键由主服务器控制，自己不能删除

## RDB 创建与载入
* SAVE 阻塞
* BGSAVE　派生子进程

因为AOF更新频率高，如果 AOF开启，优先使用AOF。

#### RDB 文件结构
RDB文件保存字符串大于 20字节会压缩后进行保存，小于等于 20字节原样保存。REDIS_RDB_ENC_LZF 常量标志字符串已经被 LZF算法压缩过了，读入时通过 compressed_len, origin_len, compressed_string 三部分对字符串解压缩。


## AOF持久化
#### AOF文件的载入与数据还原
创建一个不带网络连接的伪客户端执行AOF文件中的命令。

#### AOF重写(BGREWRITEAOF)
为了防止AOF文件膨胀，提供了AOF重写。通过读取当前的数据库状态进行重写。如果重写时集合元素超过 64个，则会分成多条写入。

#### AOF重写期间数据一致性
使用 AOF重写缓冲区，客户端发送命令时，同时追加命令到 AOF缓冲区和 AOF重写缓冲区。
1. 当 AOF重写缓冲区中所有内容都写入新 AOF文件中时，新的 AOF和当前数据库一致
2. 对新的 AOF文件进行改名，覆盖现有 AOF文件，完成新旧 AOF文件互换

## 事件
1. 文件事件
2. 时间事件（如serverCron函数）

## 服务器
#### 命令请求过程
1. 发送命令请求
2. 读取命令请求
3. 查找命令表
4. 执行预备操作
5. 调用命令函数
6. 执行后续工作
7. 回复命令　

#### serverCron 函数

#### 初始化服务器

## 复制
#### 旧版复制 SYNC
Redis 2.8之前，断点重新连接后重新执行一次 SYNC 命令，效率低。

#### 新版复制 PSYNC(partial resync)
1. 根据 runId判断从服务器是断线重连还是新连接
2. 复制偏移量记录上次复制到哪
3. 复制积压缓冲区(FIFO队列)记录断线期间的命令，超出缓冲区容量将完整复制

## Sentinel
#### 启动并初始化 Sentinel
创建向主服务器的网络连接：
1. 命令连接
2. 订阅连接

#### 获取主服务器信息
Sentinel默认以每十秒一次的频率，通过命令连接向被监视的主服务器发送INFO命令，并通过分析INFO命令的回复来获取主服务器的当前信息。

#### 获取从服务器信息
根据主服务器记录的从服务器信息，Sentinel不需要用户提供从服务器地址，就可以自动发现从服务器。以此与从服务器建立2个连接之后，即可直接向从服务器发送INFO命令查询状态并更新。

监视同一个主服务器的多个Sentinel可以自动发现对方。Sentinel之间不会创建订阅连接。

#### 检测下线状态

#### 选举领头 Sentinel(Raft算法的领头选举)

##### 选出新的主服务器
1. 从服务器优先级
2. 偏移量(偏移量最大的保存着最新的数据)
3. 运行ID 最小的服务器

## 集群
#### CLUSTER MEET命令的实现

#### 槽指派
节点会通过发送消息告知集群中的其他节点，自己目前正在负责处理哪些槽。

#### 在集群中执行命令
MOVED　错误。

#### 计算键属于哪个槽

#### 重新分片
* 重复单个槽重新分片步骤
* ASK错误
* ASK错误和 MOVED错误的区别

#### 故障检测
> 在线状态  
> 疑似下线状态 - PFAIL  
> 已下线状态 - FAIL  

集群中各个节点会通过互相发送消息的方式来交换集群中各个节点的状态信息。半数以上负责处理槽的主节点都将某个主节点x报告为疑似下线，那么这个主节点x将被标记为已下线。

#### 选举新的主节点(Raft算法的领头选举)

## 发布与订阅
所有频道的订阅关系保存在 pubsub_channels字典中，键是被订阅的频道，值则是一个链表，记录了所有订阅这个频道的客户端。

## 事务
MULTI, EXEC, WATCH, DISCARD
#### 事务的实现
1. 事务开始
2. 命令入队
3. 事务执行

## 排序

## 慢查询日志

------

## 选举领头
#### 选举领头 Sentinel(Raft算法的领头选举)
#### 选出新的主服务器
#### Cluster 选举新的主节点(Raft算法的领头选举)

## 故障转移
#### Sentinel故障转移
选举领头 Sentinel　　
选出新的主服务器

#### Cluster故障转移
选举新的主节点


